diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/childapp.py freevo/childapp.py
--- freevo.orig/childapp.py	Fri Sep  6 15:54:06 2002
+++ freevo/childapp.py	Fri Sep  6 15:56:51 2002
@@ -31,6 +31,7 @@
         self.t2 = Read_Thread('stderr', self.errfile, self.stderr_cb)
         self.t2.start()
 
+
         if DEBUG:
             time.sleep(0.5)
             print 'ChildApp.__init__(), pid=%s, app=%s, poll=%s' % (self.child.pid, app, self.child.poll())
@@ -67,7 +68,6 @@
                 self.child.wait()
             except:
                 pass
-
         
 class Read_Thread(threading.Thread):
 
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/freevo_config.py freevo/freevo_config.py
--- freevo.orig/freevo_config.py	Fri Sep  6 15:54:06 2002
+++ freevo/freevo_config.py	Fri Sep  6 18:52:02 2002
@@ -220,6 +220,29 @@
 # 
 SUFFIX_IMAGE_FILES = [ '/*.[jJ][pP][gG]' ]
 
+# ======================================================================
+# Freevo mame settings:
+# ======================================================================
+
+#
+# Where the mame files can be found.
+#
+DIR_MAME = [ ('Test Games', './testfiles/Mame') ]
+
+#
+# The list of filename suffixes that are used to match the files that
+# are used for the image viewer. They are used as the argument to glob.glob()
+# 
+SUFFIX_MAME_FILES = [ '/*.[zZ][iI][pP]' ]
+
+MAME_CMD	 = 'xmame.SDL'
+
+MAME_NICE        = '0'             # Priority of mplayer process. 0 is unchanged,
+                                      # <0 is higher prio, >0 lower prio. You must run
+                                      # freevo as root to use prio <0 !
+
+MAME_ARGS_DEF     = ('-nosound -fullscreen -modenumber 6 -ef 1')
+
 
 
 # ======================================================================
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/main.py freevo/main.py
--- freevo.orig/main.py	Fri Sep  6 15:54:06 2002
+++ freevo/main.py	Fri Sep  6 16:03:36 2002
@@ -121,6 +121,8 @@
 import tv      # The TV module
 import imenu   # The Image viewer module
 import mplayer
+import videogame      # The VideoGame Module
+import mame           # The Mame Module
 
 import identifymedia
 
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/mame.py freevo/mame.py
--- freevo.orig/mame.py	Wed Dec 31 19:00:00 1969
+++ freevo/mame.py	Fri Sep  6 18:52:25 2002
@@ -0,0 +1,252 @@
+#if 0
+# -----------------------------------------------------------------------
+# mame.py - the Freevo mame module. 
+# -----------------------------------------------------------------------
+#endif
+
+
+import sys
+import random
+import time, os, glob
+import string, popen2, fcntl, select, struct
+import threading, signal
+
+import config     # Configuration handler. reads config file.
+import util       # Various utilities
+import childapp   # Handle child applications
+import menu       # The menu widget class
+import mixer      # Controls the volumes for playback and recording
+import osd        # The OSD class, used to communicate with the OSD daemon
+import rc         # The RemoteControl class.
+import audioinfo  # This just for ID3 functions and stuff.
+import skin       # Cause audio handling needs skin functions.
+
+DEBUG = 1
+TRUE  = 1
+FALSE = 0
+
+# Setting up the default objects:
+osd        = osd.get_singleton()
+rc         = rc.get_singleton()
+menuwidget = menu.get_singleton()
+mixer      = mixer.get_singleton()
+skin       = skin.get_singleton()
+
+# Module variable that contains an initialized Mame() object
+_singleton = None
+
+def get_singleton():
+    global _singleton
+
+    # One-time init
+    if _singleton == None:
+        _singleton = Mame()
+        
+    return _singleton
+
+class Mame:
+
+    def __init__(self):
+        self.thread = Mame_Thread()
+        self.thread.start()
+        self.mode = None
+                         
+    def play(self, mode, filename, playlist, repeat=0, mame_options=""):
+
+        if DEBUG:
+            print 'mame.play(): mode=%s, filename=%s' % (mode, filename)
+            
+        self.mode   = mode   # setting global var to mode.
+        self.repeat = repeat # Repeat playlist setting
+
+        if( (mode == 'mame') and
+            not os.path.isfile(filename) ):
+            osd.clearscreen()
+            osd.drawstring('File "%s" not found!' % filename, 30, 280)
+            osd.update()
+            time.sleep(2.0) 
+            menuwidget.refresh()
+            return 0
+       
+        # build mame command
+
+        mpl = (config.NICE + " -" + config.MAME_NICE + " " +
+               config.MAME_CMD + ' ' + config.MAME_ARGS_DEF)
+
+        if mode == 'mame':
+
+            # Add special arguments for the hole playlist from the
+            # XML file
+            if mame_options:
+                mpl += (' ' + mame_options)
+                if DEBUG: print 'options, mpl = "%s"' % mpl
+
+            # Some files needs special arguments to mame, they can be
+            # put in a <filename>.mame options file. The <filename>
+            # includes the suffix (.avi, etc)!
+            # The arguments in the options file are added at the end of the
+            # regular mame arguments.
+            if os.path.isfile(filename + '.mame'):
+                mpl += (' ' + open(filename + '.mame').read().strip())
+                if DEBUG: print 'Read options, mpl = "%s"' % mpl
+
+
+            # XXX Some testcode by Krister:
+            if os.path.isfile('./freevo_xwin') and osd.sdl_driver == 'x11':
+                if DEBUG: print 'Got freevo_xwin and x11'
+                os.system('rm -f /tmp/freevo.wid')
+                os.system('./freevo_xwin  0 0 %s %s > /tmp/freevo.wid &' %
+                          (osd.width, osd.height))
+                time.sleep(1)
+                
+            command = mpl + ' "' + filename + '"'
+            
+
+
+        self.filename = filename 
+        self.playlist = playlist
+
+        # XXX A better place for the major part of this code would be
+        # XXX mixer.py
+        if config.CONTROL_ALL_AUDIO:
+            mixer.setLineinVolume( 0 )
+            mixer.setMicVolume( 0 )
+            if( config.MAJOR_AUDIO_CTRL == 'VOL' ):
+                mixer.setPcmVolume( 100 )
+            elif( config.MAJOR_AUDIO_CTRL == 'PCM' ):
+                mixer.setMainVolume( 100 )
+                
+        mixer.setIgainVolume( 0 ) # SB Live input from TV Card.
+        # This should _really_ be set to zero when playing other audio.
+
+        # clear the screen for mame
+        osd.clearscreen(color=osd.COL_BLACK)
+        osd.update()
+
+        self.mame_options = mame_options
+
+        if DEBUG:
+            print 'Mame.play(): Starting thread, cmd=%s' % command
+            
+        self.thread.mode    = 'play'
+        self.thread.command = command
+        self.thread.mode_flag.set()
+        rc.app = self.eventhandler
+        
+    def stop(self):
+        # self.thread.audioinfo = None
+        self.thread.mode = 'stop'
+        self.thread.mode_flag.set()
+        while self.thread.mode == 'stop':
+            time.sleep(0.3)
+
+
+    def eventhandler(self, event):
+        if event == rc.STOP or event == rc.SELECT:
+            self.stop()
+            rc.app = None
+            menuwidget.refresh()
+        elif event == rc.MENU:
+            self.thread.app.write('M')
+        elif event == rc.DISPLAY:
+            self.thread.cmd( 'config' )
+        elif event == rc.PAUSE or event == rc.PLAY:
+            self.thread.cmd('pause')
+        elif event == rc.ENTER:
+            self.thread.cmd('reset')
+        elif event == rc.REC:
+            self.thread.cmd('snapshot')
+            
+# ======================================================================
+class MameApp(childapp.ChildApp):
+        
+    def kill(self):
+        childapp.ChildApp.kill(self, signal.SIGINT)
+        osd.update()
+
+
+# ======================================================================
+class Mame_Thread(threading.Thread):
+
+    def __init__(self):
+        threading.Thread.__init__(self)
+        
+        self.mode      = 'idle'
+        self.mode_flag = threading.Event()
+        self.command   = ''
+        self.app       = None
+        self.audioinfo = None              # Added to enable update of GUI
+
+    def run(self):
+        while 1:
+            if self.mode == 'idle':
+                self.mode_flag.wait()
+                self.mode_flag.clear()
+                
+            elif self.mode == 'play':
+
+                if DEBUG:
+                    print 'Mame_Thread.run(): Started, cmd=%s' % self.command
+                
+                osd.stopdisplay()     
+                self.app = MameApp(self.command)
+                time.sleep(2.0)
+                osd.restartdisplay()
+		#time.sleep(1.0)
+                #os.system('./fbcon/mga_ntsc_768x576.sh')
+
+                while self.mode == 'play' and self.app.isAlive():
+                    # if DEBUG: print "Still running..."
+                    time.sleep(0.1)
+
+                self.app.kill()
+
+                if self.mode == 'play':
+                    rc.post_event(rc.STOP)
+
+                self.mode = 'idle'
+                
+            else:
+                self.mode = 'idle'
+
+
+    def cmd(self, command):
+        print "In cmd going to do: " + command
+        str = ''
+        if command == 'config':
+            str = mameKey('CONFIGMENU')
+        elif command == 'pause':
+            str = mameKey('PAUSE')
+        elif command == 'reset':
+            str = mameKey('RESET')
+        elif command == 'exit':
+            str = mameKey('EXIT')
+        elif command == 'snapshot':
+            str = mameKey('SNAPSHOT')
+
+        self.app.write(str) 
+
+
+#
+# Translate an abstract remote control command to an mame
+# command key
+#
+def mameKey(rcCommand):
+    mameKeys = {
+        'CONFIGMENU'     : '\x09',
+        'PAUSE'          : 'P',
+        'RESET'          : '\x1b[[13~',
+        'EXIT'           : '\x1b',
+        'SNAPSHOT'       : '\x1b[[24~'
+        }
+    
+    key = mameKeys.get(rcCommand, '')
+
+    return key
+
+
+# Test code
+if __name__ == '__main__':
+    player = get_singleton()
+
+    player.play('audio', sys.argv[1], None)
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/osd.py freevo/osd.py
--- freevo.orig/osd.py	Fri Sep  6 15:54:06 2002
+++ freevo/osd.py	Fri Sep  6 18:45:34 2002
@@ -246,6 +246,9 @@
 
     def _cb(self):
 
+        if not pygame.display.get_init():
+            return None
+
         # Check if mouse should be visible or hidden
         mouserel = pygame.mouse.get_rel()
         mousedist = (mouserel[0]**2 + mouserel[1]**2) ** 0.5
@@ -286,8 +289,19 @@
     def shutdown(self):
         pygame.quit()
 
+    def restartdisplay(self):
+	pygame.display.init()
+        self.width = config.CONF.width
+        self.height = config.CONF.height
+        self.screen = pygame.display.set_mode((self.width, self.height), 0, 32)
+
+    def stopdisplay(self):
+	pygame.display.quit()
 
     def clearscreen(self, color=None):
+        if not pygame.display.get_init():
+            return None
+
         if color == None:
             color = self.default_bg_color
         self.screen.fill(self._sdlcol(color))
@@ -325,6 +339,9 @@
     # Loads and zooms a bitmap and return the surface. A cache is currently
     # missing, but maybe we don't need it, it's fast enough.
     def zoombitmap(self, filename, scaling=None, bbx=0, bby=0, bbw=0, bbh=0, rotation = 0):
+        if not pygame.display.get_init():
+            return None
+
         image = self._getbitmap(filename)
 
         if not image: return
@@ -355,19 +372,24 @@
     # be used to "pipeline" bitmap loading/drawing.
     def drawbitmap(self, filename, x=0, y=0, scaling=None,
                    bbx=0, bby=0, bbw=0, bbh=0, rotation = 0):
-
+        if not pygame.display.get_init():
+            return None
         image = self.zoombitmap(filename, scaling, bbx, bby, bbw, bbh, rotation)
         if not image: return
         self.screen.blit(image, (x, y))
 
 
     def bitmapsize(self, filename):
+        if not pygame.display.get_init():
+            return None
         image = self._getbitmap(filename)
         if not image: return 0,0
         return image.get_size()
 
 
     def drawline(self, x0, y0, x1, y1, width=None, color=None):
+        if not pygame.display.get_init():
+            return None
         if width == None:
             width = 1
 
@@ -380,6 +402,8 @@
 
 
     def drawbox(self, x0, y0, x1, y1, width=None, color=None, fill=0):
+        if not pygame.display.get_init():
+            return None
 
         # Make sure the order is top left, bottom right
         x0, x1 = min(x0, x1), max(x0, x1)
@@ -408,6 +432,9 @@
     def drawstring(self, string, x, y, fgcolor=None, bgcolor=None,
                    font=None, ptsize=0, align='left'):
 
+        if not pygame.display.get_init():
+            return None
+
         # XXX Krister: Workaround for new feature that is only possible in the new
         # XXX SDL OSD, line up columns delimited by tabs. Here the tabs are just
         # XXX replaced with spaces
@@ -442,6 +469,9 @@
     # Render a string to an SDL surface. Uses a cache for speedup.
     def _renderstring(self, string, font, ptsize, fgcolor, bgcolor):
 
+        if not pygame.display.get_init():
+            return None
+
         f = self._getfont(font, ptsize)
 
         if not f:
@@ -476,6 +506,10 @@
 
         
     def popup_box(self, text):
+
+        if not pygame.display.get_init():
+            return None
+
         """
         Trying to make a standard popup/dialog box for various usages.
         Currently it just draws itself in the middle of the screen.
@@ -504,6 +538,9 @@
 
     # Return a (width, height) tuple for the given string, font, size
     def stringsize(self, string, font=None, ptsize=0):
+        if not pygame.display.get_init():
+            return None
+
         if not ptsize:
             ptsize = config.OSD_DEFAULT_FONTSIZE
 
@@ -518,10 +555,17 @@
         
 
     def update(self):
+
+        if not pygame.display.get_init():
+            return None
+
         pygame.display.flip()
 
 
     def _getfont(self, filename, ptsize):
+        if not pygame.display.get_init():
+            return None
+
         for font in self.fontcache:
             if font.filename == filename and font.ptsize == ptsize:
                 return font.font
@@ -539,6 +583,8 @@
 
         
     def _getbitmap(self, filename):
+        if not pygame.display.get_init():
+            return None
 
         if not os.path.isfile(filename):
             print 'Bitmap file "%s" doesnt exist!' % filename
@@ -574,6 +620,9 @@
                 del self.bitmapcache[i]
         
     def _helpscreen(self):
+        if not pygame.display.get_init():
+            return None
+
         self._help = {0:1, 1:0}[self._help]
         
         if self._help:
Binary files freevo.orig/rominfo and freevo/rominfo differ
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/rominfosrc/makefile freevo/rominfosrc/makefile
--- freevo.orig/rominfosrc/makefile	Wed Dec 31 19:00:00 1969
+++ freevo/rominfosrc/makefile	Thu Sep  5 09:01:16 2002
@@ -0,0 +1,57 @@
+#
+# I have included comments for the benefit of makefile newbies :)
+#
+
+CC=@gcc
+LD=@gcc
+MD=mkdir
+
+SRC=src
+
+OBJ=obj
+OBJDIRS=$(OBJ) $(OBJ)/mame $(OBJ)/mame/msdos
+OBJS=$(OBJ)/mame/msdos/msdos.o $(OBJ)/mame/unzip.o $(OBJ)/rominfo.o
+
+EXE=rominfo
+
+LIBS=-lz
+
+#
+# Build the obj tree then build the EXE
+#
+
+all: maketree $(EXE)
+
+#
+# Creating obj directory tree
+#
+
+maketree: $(sort $(OBJDIRS))
+
+$(sort $(OBJDIRS)):
+	$(MD) $@
+
+#
+# Linking the object files to make the EXE
+#
+
+$(EXE): $(OBJS)
+	@echo Linking $@...
+	$(LD) $(OBJS) $(LIBS) -o $@
+
+
+#
+# Building of each module from MAME (and another for ROMBuild)
+#
+
+$(OBJ)/mame/msdos/msdos.o: $(SRC)/mame/msdos/msdos.c
+	@echo Compiling $@...
+	$(CC) $< -c -o $@
+
+$(OBJ)/mame/unzip.o: $(SRC)/mame/unzip.c $(SRC)/mame/unzip.h $(SRC)/mame/osd_cpu.h
+	@echo Compiling $@...
+	$(CC) $< -c -o $@
+
+$(OBJ)/rominfo.o: $(SRC)/rominfo.c $(SRC)/rominfo.h
+	@echo Compiling $@...
+	$(CC) $< -c -o $@
Binary files freevo.orig/rominfosrc/obj/mame/msdos/msdos.o and freevo/rominfosrc/obj/mame/msdos/msdos.o differ
Binary files freevo.orig/rominfosrc/obj/mame/unzip.o and freevo/rominfosrc/obj/mame/unzip.o differ
Binary files freevo.orig/rominfosrc/obj/rominfo.o and freevo/rominfosrc/obj/rominfo.o differ
Binary files freevo.orig/rominfosrc/rominfo and freevo/rominfosrc/rominfo differ
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/rominfosrc/rominfo.txt freevo/rominfosrc/rominfo.txt
--- freevo.orig/rominfosrc/rominfo.txt	Wed Dec 31 19:00:00 1969
+++ freevo/rominfosrc/rominfo.txt	Fri Sep  6 16:16:01 2002
@@ -0,0 +1,10 @@
+Make generates rominfo
+
+usage
+-----
+rominfo /path/to/mame/game.zip
+
+Make sure you do a "xmame -listinfo > /usr/local/freevo/rominfodats/mame.dat" first
+
+currently the path to the dats are hardcoded as ./rominfodats
+
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/rominfosrc/src/mame/msdos/msdos.c freevo/rominfosrc/src/mame/msdos/msdos.c
--- freevo.orig/rominfosrc/src/mame/msdos/msdos.c	Wed Dec 31 19:00:00 1969
+++ freevo/rominfosrc/src/mame/msdos/msdos.c	Thu Sep  5 08:59:19 2002
@@ -0,0 +1,4 @@
+logerror(char *msg, ...)
+{
+	/* MAME's unzip routines use this function but I don't */
+}
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/rominfosrc/src/mame/osd_cpu.h freevo/rominfosrc/src/mame/osd_cpu.h
--- freevo.orig/rominfosrc/src/mame/osd_cpu.h	Wed Dec 31 19:00:00 1969
+++ freevo/rominfosrc/src/mame/osd_cpu.h	Thu Sep  5 08:50:18 2002
@@ -0,0 +1,78 @@
+/*******************************************************************************
+*					
+*	Define size independent data types and operations.		
+*								
+*   The following types must be supported by all platforms:	
+*						
+*	UINT8  - Unsigned 8-bit Integer		INT8  - Signed 8-bit integer         
+*	UINT16 - Unsigned 16-bit Integer	INT16 - Signed 16-bit integer         
+*	UINT32 - Unsigned 32-bit Integer	INT32 - Signed 32-bit integer         
+*	UINT64 - Unsigned 64-bit Integer	INT64 - Signed 64-bit integer         
+*							
+*																			   
+*   The macro names for the artithmatic operations are composed as follows:    
+*																		   
+*   XXX_R_A_B, where XXX - 3 letter operation code (ADD, SUB, etc.)			   
+*					 R   - The type	of the result							   
+*					 A   - The type of operand 1							   
+*			         B   - The type of operand 2 (if binary operation)		   
+*																		   
+*				     Each type is one of: U8,8,U16,16,U32,32,U64,64			   
+*																			   
+*******************************************************************************/
+
+
+#ifndef OSD_CPU_H
+#define OSD_CPU_H
+
+
+typedef unsigned char						UINT8;
+typedef unsigned short						UINT16;
+typedef unsigned int						UINT32;
+__extension__ typedef unsigned long long	UINT64;
+typedef signed char 						INT8;
+typedef signed short						INT16;
+typedef signed int							INT32;
+__extension__ typedef signed long long		INT64;
+
+/* Combine two 32-bit integers into a 64-bit integer */
+#define COMBINE_64_32_32(A,B)     ((((UINT64)(A))<<32) | (B))
+#define COMBINE_U64_U32_U32(A,B)  COMBINE_64_32_32(A,B)
+
+/* Return upper 32 bits of a 64-bit integer */
+#define HI32_32_64(A)		  (((UINT64)(A)) >> 32)
+#define HI32_U32_U64(A)		  HI32_32_64(A)
+
+/* Return lower 32 bits of a 64-bit integer */
+#define LO32_32_64(A)		  ((A) & 0xffffffff)
+#define LO32_U32_U64(A)		  LO32_32_64(A)
+
+#define DIV_64_64_32(A,B)	  ((A)/(B))
+#define DIV_U64_U64_U32(A,B)  ((A)/(UINT32)(B))
+
+#define MOD_32_64_32(A,B)	  ((A)%(B))
+#define MOD_U32_U64_U32(A,B)  ((A)%(UINT32)(B))
+
+#define MUL_64_32_32(A,B)	  ((A)*(INT64)(B))
+#define MUL_U64_U32_U32(A,B)  ((A)*(UINT64)(UINT32)(B))
+
+
+/******************************************************************************
+ * Union of UINT8, UINT16 and UINT32 in native endianess of the target
+ * This is used to access bytes and words in a machine independent manner.
+ * The upper bytes h2 and h3 normally contain zero (16 bit CPU cores)
+ * thus PAIR.d can be used to pass arguments to the memory system
+ * which expects 'int' really.
+ ******************************************************************************/
+typedef union {
+#ifdef LSB_FIRST
+	struct { UINT8 l,h,h2,h3; } b;
+	struct { UINT16 l,h; } w;
+#else
+	struct { UINT8 h3,h2,h,l; } b;
+	struct { UINT16 h,l; } w;
+#endif
+	UINT32 d;
+}	PAIR;
+
+#endif	/* defined OSD_CPU_H */
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/rominfosrc/src/mame/unzip.c freevo/rominfosrc/src/mame/unzip.c
--- freevo.orig/rominfosrc/src/mame/unzip.c	Wed Dec 31 19:00:00 1969
+++ freevo/rominfosrc/src/mame/unzip.c	Thu Sep  5 08:58:13 2002
@@ -0,0 +1,850 @@
+#include "unzip.h"
+//#include "mame.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <ctype.h>
+#include <assert.h>
+#include <zlib.h>
+
+/* public globals */
+int	gUnzipQuiet = 0;		/* flag controls error messages */
+
+
+#define ERROR_CORRUPT "The zipfile seems to be corrupt, please check it"
+#define ERROR_FILESYSTEM "Your filesystem seems to be corrupt, please check it"
+#define ERROR_UNSUPPORTED "The format of this zipfile is not supported, please recompress it"
+
+#define INFLATE_INPUT_BUFFER_MAX 16384
+#ifndef MIN
+#define MIN(x,y) ((x)<(y)?(x):(y))
+#endif
+
+/* Print a error message */
+void errormsg(const char* extmsg, const char* usermsg, const char* zipname) {
+	/* Output to the user with no internal detail */
+	if (!gUnzipQuiet)
+		printf("Error in zipfile %s\n%s\n", zipname, usermsg);
+	/* Output to log file with all informations */
+	logerror("Error in zipfile %s: %s\n", zipname, extmsg);
+}
+
+/* -------------------------------------------------------------------------
+   Unzip support
+ ------------------------------------------------------------------------- */
+
+/* Use these to avoid structure padding and byte-ordering problems */
+static UINT16 read_word (char *buf) {
+   unsigned char *ubuf = (unsigned char *) buf;
+
+   return ((UINT16)ubuf[1] << 8) | (UINT16)ubuf[0];
+}
+
+/* Use these to avoid structure padding and byte-ordering problems */
+static UINT32 read_dword (char *buf) {
+   unsigned char *ubuf = (unsigned char *) buf;
+
+   return ((UINT32)ubuf[3] << 24) | ((UINT32)ubuf[2] << 16) | ((UINT32)ubuf[1] << 8) | (UINT32)ubuf[0];
+}
+
+/* Locate end-of-central-dir sig in buffer and return offset
+   out:
+	*offset offset of cent dir start in buffer
+   return:
+	==0 not found
+	!=0 found, *offset valid
+*/
+static int ecd_find_sig (char *buffer, int buflen, int *offset)
+{
+	static char ecdsig[] = { 'P', 'K', 0x05, 0x06 };
+	int i;
+	for (i=buflen-22; i>=0; i--) {
+		if (memcmp(buffer+i, ecdsig, 4) == 0) {
+			*offset = i;
+			return 1;
+		}
+	}
+	return 0;
+}
+
+/* Read ecd data in zip structure
+   in:
+     zip->fp, zip->length zip file
+   out:
+     zip->ecd, zip->ecd_length ecd data
+*/
+static int ecd_read(ZIP* zip) {
+	char* buf;
+	int buf_length = 1024; /* initial buffer length */
+
+	while (1) {
+		int offset;
+
+		if (buf_length > zip->length)
+			buf_length = zip->length;
+
+		if (fseek(zip->fp, zip->length - buf_length, SEEK_SET) != 0) {
+			return -1;
+		}
+
+		/* allocate buffer */
+		buf = (char*)malloc( buf_length );
+		if (!buf) {
+			return -1;
+		}
+
+		if (fread( buf, buf_length, 1, zip->fp ) != 1) {
+			free(buf);
+			return -1;
+		}
+
+		if (ecd_find_sig(buf, buf_length, &offset)) {
+			zip->ecd_length = buf_length - offset;
+
+			zip->ecd = (char*)malloc( zip->ecd_length );
+			if (!zip->ecd) {
+				free(buf);
+				return -1;
+			}
+
+			memcpy(zip->ecd, buf + offset, zip->ecd_length);
+
+			free(buf);
+			return 0;
+		}
+
+		free(buf);
+
+		if (buf_length < zip->length) {
+			/* double buffer */
+			buf_length = 2*buf_length;
+
+			logerror("Retry reading of zip ecd for %d bytes\n",buf_length);
+
+		} else {
+			return -1;
+		}
+	}
+}
+
+/* offsets in end of central directory structure */
+#define ZIPESIG		0x00
+#define ZIPEDSK		0x04
+#define ZIPECEN		0x06
+#define ZIPENUM		0x08
+#define ZIPECENN	0x0a
+#define ZIPECSZ		0x0c
+#define ZIPEOFST	0x10
+#define ZIPECOML	0x14
+#define ZIPECOM		0x16
+
+/* offsets in central directory entry structure */
+#define ZIPCENSIG	0x0
+#define ZIPCVER		0x4
+#define ZIPCOS		0x5
+#define	ZIPCVXT		0x6
+#define	ZIPCEXOS	0x7
+#define ZIPCFLG		0x8
+#define ZIPCMTHD	0xa
+#define ZIPCTIM		0xc
+#define ZIPCDAT		0xe
+#define ZIPCCRC		0x10
+#define ZIPCSIZ		0x14
+#define ZIPCUNC		0x18
+#define ZIPCFNL		0x1c
+#define ZIPCXTL		0x1e
+#define ZIPCCML		0x20
+#define ZIPDSK		0x22
+#define ZIPINT		0x24
+#define ZIPEXT		0x26
+#define ZIPOFST		0x2a
+#define ZIPCFN		0x2e
+
+/* offsets in local file header structure */
+#define ZIPLOCSIG	0x00
+#define ZIPVER		0x04
+#define ZIPGENFLG	0x06
+#define ZIPMTHD		0x08
+#define ZIPTIME		0x0a
+#define ZIPDATE		0x0c
+#define ZIPCRC		0x0e
+#define ZIPSIZE		0x12
+#define ZIPUNCMP	0x16
+#define ZIPFNLN		0x1a
+#define ZIPXTRALN	0x1c
+#define ZIPNAME		0x1e
+
+/* Opens a zip stream for reading
+   return:
+     !=0 success, zip stream
+     ==0 error
+*/
+ZIP* openzip(const char* zipfile) {
+	/* allocate */
+	ZIP* zip = (ZIP*)malloc( sizeof(ZIP) );
+	if (!zip) {
+		return 0;
+	}
+
+	/* open */
+	zip->fp = fopen(zipfile, "rb");
+	if (!zip->fp) {
+		errormsg ("Opening for reading", ERROR_FILESYSTEM, zipfile);
+		free(zip);
+		return 0;
+	}
+
+	/* go to end */
+	if (fseek(zip->fp, 0L, SEEK_END) != 0) {
+		errormsg ("Seeking to end", ERROR_FILESYSTEM, zipfile);
+		fclose(zip->fp);
+		free(zip);
+		return 0;
+	}
+
+	/* get length */
+	zip->length = ftell(zip->fp);
+	if (zip->length < 0) {
+		errormsg ("Get file size", ERROR_FILESYSTEM, zipfile);
+		fclose(zip->fp);
+		free(zip);
+		return 0;
+	}
+	if (zip->length == 0) {
+		errormsg ("Empty file", ERROR_CORRUPT, zipfile);
+		fclose(zip->fp);
+		free(zip);
+		return 0;
+	}
+
+	/* read ecd data */
+	if (ecd_read(zip)!=0) {
+		errormsg ("Reading ECD (end of central directory)", ERROR_CORRUPT, zipfile);
+		fclose(zip->fp);
+		free(zip);
+		return 0;
+	}
+
+	/* compile ecd info */
+	zip->end_of_cent_dir_sig = read_dword (zip->ecd+ZIPESIG);
+	zip->number_of_this_disk = read_word (zip->ecd+ZIPEDSK);
+	zip->number_of_disk_start_cent_dir = read_word (zip->ecd+ZIPECEN);
+	zip->total_entries_cent_dir_this_disk = read_word (zip->ecd+ZIPENUM);
+	zip->total_entries_cent_dir = read_word (zip->ecd+ZIPECENN);
+	zip->size_of_cent_dir = read_dword (zip->ecd+ZIPECSZ);
+	zip->offset_to_start_of_cent_dir = read_dword (zip->ecd+ZIPEOFST);
+	zip->zipfile_comment_length = read_word (zip->ecd+ZIPECOML);
+	zip->zipfile_comment = zip->ecd+ZIPECOM;
+
+	/* verify that we can work with this zipfile (no disk spanning allowed) */
+	if ((zip->number_of_this_disk != zip->number_of_disk_start_cent_dir) ||
+		(zip->total_entries_cent_dir_this_disk != zip->total_entries_cent_dir) ||
+		(zip->total_entries_cent_dir < 1)) {
+		errormsg("Cannot span disks", ERROR_UNSUPPORTED, zipfile);
+		free(zip->ecd);
+		fclose(zip->fp);
+		free(zip);
+		return 0;
+	}
+
+	if (fseek(zip->fp, zip->offset_to_start_of_cent_dir, SEEK_SET)!=0) {
+		errormsg ("Seeking to central directory", ERROR_CORRUPT, zipfile);
+		free(zip->ecd);
+		fclose(zip->fp);
+		free(zip);
+		return 0;
+	}
+
+	/* read from start of central directory */
+	zip->cd = (char*)malloc( zip->size_of_cent_dir );
+	if (!zip->cd) {
+		free(zip->ecd);
+		fclose(zip->fp);
+		free(zip);
+		return 0;
+	}
+
+	if (fread(zip->cd, zip->size_of_cent_dir, 1, zip->fp)!=1) {
+		errormsg ("Reading central directory", ERROR_CORRUPT, zipfile);
+		free(zip->cd);
+		free(zip->ecd);
+		fclose(zip->fp);
+		free(zip);
+		return 0;
+	}
+
+	/* reset ent */
+	zip->ent.name = 0;
+
+	/* rewind */
+	zip->cd_pos = 0;
+
+	/* file name */
+	zip->zip = (char*)malloc(strlen(zipfile)+1);
+	if (!zip->zip) {
+		free(zip->cd);
+		free(zip->ecd);
+		fclose(zip->fp);
+		free(zip);
+		return 0;
+	}
+	strcpy(zip->zip, zipfile);
+
+	return zip;
+}
+
+/* Reads the current entry from a zip stream
+   in:
+     zip opened zip
+   return:
+     !=0 success
+     ==0 error
+*/
+struct zipent* readzip(ZIP* zip) {
+
+	/* end of directory */
+	if (zip->cd_pos >= zip->size_of_cent_dir)
+		return 0;
+
+	/* compile zipent info */
+	zip->ent.cent_file_header_sig = read_dword (zip->cd+zip->cd_pos+ZIPCENSIG);
+	zip->ent.version_made_by = *(zip->cd+zip->cd_pos+ZIPCVER);
+	zip->ent.host_os = *(zip->cd+zip->cd_pos+ZIPCOS);
+	zip->ent.version_needed_to_extract = *(zip->cd+zip->cd_pos+ZIPCVXT);
+	zip->ent.os_needed_to_extract = *(zip->cd+zip->cd_pos+ZIPCEXOS);
+	zip->ent.general_purpose_bit_flag = read_word (zip->cd+zip->cd_pos+ZIPCFLG);
+	zip->ent.compression_method = read_word (zip->cd+zip->cd_pos+ZIPCMTHD);
+	zip->ent.last_mod_file_time = read_word (zip->cd+zip->cd_pos+ZIPCTIM);
+	zip->ent.last_mod_file_date = read_word (zip->cd+zip->cd_pos+ZIPCDAT);
+	zip->ent.crc32 = read_dword (zip->cd+zip->cd_pos+ZIPCCRC);
+	zip->ent.compressed_size = read_dword (zip->cd+zip->cd_pos+ZIPCSIZ);
+	zip->ent.uncompressed_size = read_dword (zip->cd+zip->cd_pos+ZIPCUNC);
+	zip->ent.filename_length = read_word (zip->cd+zip->cd_pos+ZIPCFNL);
+	zip->ent.extra_field_length = read_word (zip->cd+zip->cd_pos+ZIPCXTL);
+	zip->ent.file_comment_length = read_word (zip->cd+zip->cd_pos+ZIPCCML);
+	zip->ent.disk_number_start = read_word (zip->cd+zip->cd_pos+ZIPDSK);
+	zip->ent.internal_file_attrib = read_word (zip->cd+zip->cd_pos+ZIPINT);
+	zip->ent.external_file_attrib = read_dword (zip->cd+zip->cd_pos+ZIPEXT);
+	zip->ent.offset_lcl_hdr_frm_frst_disk = read_dword (zip->cd+zip->cd_pos+ZIPOFST);
+
+    /* check to see if filename length is illegally long (past the size of this directory
+       entry) */
+    if (zip->cd_pos + ZIPCFN + zip->ent.filename_length > zip->size_of_cent_dir)
+    {
+        errormsg("Invalid filename length in directory", ERROR_CORRUPT,zip->zip);
+        return 0;
+    }
+
+	/* copy filename */
+	free(zip->ent.name);
+	zip->ent.name = (char*)malloc(zip->ent.filename_length + 1);
+	memcpy(zip->ent.name, zip->cd+zip->cd_pos+ZIPCFN, zip->ent.filename_length);
+	zip->ent.name[zip->ent.filename_length] = 0;
+
+	/* skip to next entry in central dir */
+	zip->cd_pos += ZIPCFN + zip->ent.filename_length + zip->ent.extra_field_length + zip->ent.file_comment_length;
+
+	return &zip->ent;
+}
+
+/* Closes a zip stream */
+void closezip(ZIP* zip) {
+	/* release all */
+	free(zip->ent.name);
+	free(zip->cd);
+	free(zip->ecd);
+	/* only if not suspended */
+	if (zip->fp)
+		fclose(zip->fp);
+	free(zip->zip);
+	free(zip);
+}
+
+/* Suspend access to a zip file (release file handler)
+   in:
+      zip opened zip
+   note:
+     A suspended zip is automatically reopened at first call of
+     readuncompressd() or readcompressed() functions
+*/
+void suspendzip(ZIP* zip) {
+	if (zip->fp) {
+		fclose(zip->fp);
+		zip->fp = 0;
+	}
+}
+
+/* Revive a suspended zip file (reopen file handler)
+   in:
+     zip suspended zip
+   return:
+	zip success
+	==0 error (zip must be closed with closezip)
+*/
+static ZIP* revivezip(ZIP* zip) {
+	if (!zip->fp) {
+		zip->fp = fopen(zip->zip, "rb");
+		if (!zip->fp) {
+			return 0;
+		}
+	}
+	return zip;
+
+}
+
+/* Reset a zip stream to the first entry
+   in:
+     zip opened zip
+   note:
+     ZIP file must be opened and not suspended
+*/
+void rewindzip(ZIP* zip) {
+	zip->cd_pos = 0;
+}
+
+/* Seek zip->fp to compressed data
+   return:
+	==0 success
+	<0 error
+*/
+int seekcompresszip(ZIP* zip, struct zipent* ent) {
+	char buf[ZIPNAME];
+	long offset;
+
+	if (!zip->fp) {
+		if (!revivezip(zip))
+			return -1;
+	}
+
+	if (fseek(zip->fp, ent->offset_lcl_hdr_frm_frst_disk, SEEK_SET)!=0) {
+		errormsg ("Seeking to header", ERROR_CORRUPT, zip->zip);
+		return -1;
+	}
+
+	if (fread(buf, ZIPNAME, 1, zip->fp)!=1) {
+		errormsg ("Reading header", ERROR_CORRUPT, zip->zip);
+		return -1;
+	}
+
+	{
+		UINT16 filename_length = read_word (buf+ZIPFNLN);
+		UINT16 extra_field_length = read_word (buf+ZIPXTRALN);
+
+		/* calculate offset to data and fseek() there */
+		offset = ent->offset_lcl_hdr_frm_frst_disk + ZIPNAME + filename_length + extra_field_length;
+
+		if (fseek(zip->fp, offset, SEEK_SET) != 0) {
+			errormsg ("Seeking to compressed data", ERROR_CORRUPT, zip->zip);
+			return -1;
+		}
+
+	}
+
+	return 0;
+}
+
+/* Inflate a file
+   in:
+   in_file stream to inflate
+   in_size size of the compressed data to read
+   out_size size of decompressed data
+   out:
+   out_data buffer for decompressed data
+   return:
+   ==0 ok
+
+   990525 rewritten for use with zlib MLR
+*/
+static int inflate_file(FILE* in_file, unsigned in_size, unsigned char* out_data, unsigned out_size)
+{
+    int err;
+	unsigned char* in_buffer;
+    z_stream d_stream; /* decompression stream */
+
+    d_stream.zalloc = 0;
+    d_stream.zfree = 0;
+    d_stream.opaque = 0;
+
+	d_stream.next_in  = 0;
+	d_stream.avail_in = 0;
+    d_stream.next_out = out_data;
+    d_stream.avail_out = out_size;
+
+    err = inflateInit2(&d_stream, -MAX_WBITS);
+	/* windowBits is passed < 0 to tell that there is no zlib header.
+	 * Note that in this case inflate *requires* an extra "dummy" byte
+	 * after the compressed stream in order to complete decompression and
+	 * return Z_STREAM_END.
+	 */
+    if (err != Z_OK)
+	{
+		logerror("inflateInit error: %d\n", err);
+        return -1;
+	}
+
+	in_buffer = (unsigned char*)malloc(INFLATE_INPUT_BUFFER_MAX+1);
+	if (!in_buffer)
+		return -1;
+
+    for (;;)
+	{
+		if (in_size <= 0)
+		{
+			logerror("inflate error: compressed size too small\n");
+			free (in_buffer);
+			return -1;
+		}
+		d_stream.next_in  = in_buffer;
+		d_stream.avail_in = fread (in_buffer, 1, MIN(in_size, INFLATE_INPUT_BUFFER_MAX), in_file);
+		in_size -= d_stream.avail_in;
+		if (in_size == 0)
+			d_stream.avail_in++; /* add dummy byte at end of compressed data */
+
+        err = inflate(&d_stream, Z_NO_FLUSH);
+        if (err == Z_STREAM_END)
+			break;
+		if (err != Z_OK)
+		{
+			logerror("inflate error: %d\n", err);
+			free (in_buffer);
+			return -1;
+		}
+    }
+
+    err = inflateEnd(&d_stream);
+	if (err != Z_OK)
+	{
+		logerror("inflateEnd error: %d\n", err);
+		free (in_buffer);
+		return -1;
+	}
+
+	free (in_buffer);
+
+	if ((d_stream.avail_out > 0) || (in_size > 0))
+	{
+		logerror("zip size mismatch. %i\n", in_size);
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Read compressed data
+   out:
+	data compressed data read
+   return:
+	==0 success
+	<0 error
+*/
+int readcompresszip(ZIP* zip, struct zipent* ent, char* data) {
+	int err = seekcompresszip(zip,ent);
+	if (err!=0)
+		return err;
+
+	if (fread(data, ent->compressed_size, 1, zip->fp)!=1) {
+		errormsg ("Reading compressed data", ERROR_CORRUPT, zip->zip);
+		return -1;
+	}
+
+	return 0;
+}
+
+/* Read UNcompressed data
+   out:
+	data UNcompressed data
+   return:
+	==0 success
+	<0 error
+*/
+int readuncompresszip(ZIP* zip, struct zipent* ent, char* data) {
+	if (ent->compression_method == 0x0000) {
+		/* file is not compressed, simply stored */
+
+		/* check if size are equal */
+		if (ent->compressed_size != ent->uncompressed_size) {
+			errormsg("Wrong uncompressed size in store compression", ERROR_CORRUPT,zip->zip);
+			return -3;
+		}
+
+		return readcompresszip(zip,ent,data);
+	} else if (ent->compression_method == 0x0008) {
+		/* file is compressed using "Deflate" method */
+		if (ent->version_needed_to_extract > 0x14) {
+			errormsg("Version too new", ERROR_UNSUPPORTED,zip->zip);
+			return -2;
+		}
+
+		if (ent->os_needed_to_extract != 0x00) {
+			errormsg("OS not supported", ERROR_UNSUPPORTED,zip->zip);
+			return -2;
+		}
+
+		if (ent->disk_number_start != zip->number_of_this_disk) {
+			errormsg("Cannot span disks", ERROR_UNSUPPORTED,zip->zip);
+			return -2;
+		}
+
+		/* read compressed data */
+		if (seekcompresszip(zip,ent)!=0) {
+			return -1;
+		}
+
+		/* configure inflate */
+		if (inflate_file( zip->fp, ent->compressed_size, (unsigned char*)data, ent->uncompressed_size))
+		{
+			errormsg("Inflating compressed data", ERROR_CORRUPT, zip->zip);
+			return -3;
+		}
+
+		return 0;
+	} else {
+		errormsg("Compression method unsupported", ERROR_UNSUPPORTED, zip->zip);
+		return -2;
+	}
+}
+
+/* -------------------------------------------------------------------------
+   Zip cache support
+ ------------------------------------------------------------------------- */
+
+/* Use the zip cache */
+#define ZIP_CACHE
+
+#ifdef ZIP_CACHE
+
+/* ZIP cache entries */
+#define ZIP_CACHE_MAX 2
+
+/* ZIP cache buffer LRU ( Last Recently Used )
+     zip_cache_map[0] is the newer
+     zip_cache_map[ZIP_CACHE_MAX-1] is the older
+*/
+static ZIP* zip_cache_map[ZIP_CACHE_MAX];
+
+static ZIP* cache_openzip(const char* zipfile) {
+	ZIP* zip;
+	unsigned i;
+
+	/* search in the cache buffer */
+	for(i=0;i<ZIP_CACHE_MAX;++i) {
+		if (zip_cache_map[i] && strcmp(zip_cache_map[i]->zip,zipfile)==0) {
+			/* found */
+			unsigned j;
+
+/*
+			logerror("Zip cache HIT  for %s\n", zipfile);
+*/
+
+			/* reset the zip directory */
+			rewindzip( zip_cache_map[i] );
+
+			/* store */
+			zip = zip_cache_map[i];
+
+			/* shift */
+			for(j=i;j>0;--j)
+				zip_cache_map[j] = zip_cache_map[j-1];
+
+			/* set the first entry */
+			zip_cache_map[0] = zip;
+
+			return zip_cache_map[0];
+		}
+	}
+	/* not found */
+
+/*
+	logerror("Zip cache FAIL for %s\n", zipfile);
+*/
+
+	/* open the zip */
+	zip = openzip( zipfile );
+	if (!zip)
+		return 0;
+
+	/* close the oldest entry */
+	if (zip_cache_map[ZIP_CACHE_MAX-1]) {
+		/* close last zip */
+		closezip(zip_cache_map[ZIP_CACHE_MAX-1]);
+		/* reset the entry */
+		zip_cache_map[ZIP_CACHE_MAX-1] = 0;
+	}
+
+	/* shift */
+	for(i=ZIP_CACHE_MAX-1;i>0;--i)
+		zip_cache_map[i] = zip_cache_map[i-1];
+
+	/* set the first entry */
+	zip_cache_map[0] = zip;
+
+	return zip_cache_map[0];
+}
+
+static void cache_closezip(ZIP* zip) {
+	unsigned i;
+
+	/* search in the cache buffer */
+	for(i=0;i<ZIP_CACHE_MAX;++i) {
+		if (zip_cache_map[i]==zip) {
+			/* close zip */
+			closezip(zip);
+
+			/* reset cache entry */
+			zip_cache_map[i] = 0;
+			return;
+
+		}
+	}
+	/* not found */
+
+	/* close zip */
+	closezip(zip);
+}
+
+/* CK980415 added to allow osd code to clear zip cache for auditing--each time
+   the user opens up an audit for a game we should reread the zip */
+void unzip_cache_clear()
+{
+	unsigned i;
+
+	/* search in the cache buffer for any zip info and clear it */
+	for(i=0;i<ZIP_CACHE_MAX;++i) {
+		if (zip_cache_map[i] != NULL) {
+			/* close zip */
+			closezip(zip_cache_map[i]);
+
+			/* reset cache entry */
+			zip_cache_map[i] = 0;
+/*			return; */
+
+		}
+	}
+}
+
+#define cache_suspendzip(a) suspendzip(a)
+
+#else
+
+#define cache_openzip(a) openzip(a)
+#define cache_closezip(a) closezip(a)
+#define cache_suspendzip(a) closezip(a)
+
+#define unzip_cache_clear()
+
+#endif
+
+/* -------------------------------------------------------------------------
+   Backward MAME compatibility
+ ------------------------------------------------------------------------- */
+
+/* Compare two filename
+   note:
+     don't check directory in zip and ignore case
+*/
+static int equal_filename(const char* zipfile, const char* file) {
+	const char* s1 = file;
+	/* start comparison after last / */
+	const char* s2 = strrchr(zipfile,'/');
+	if (s2)
+		++s2;
+	else
+		s2 = zipfile;
+	while (*s1 && toupper(*s1)==toupper(*s2)) {
+		++s1;
+		++s2;
+	}
+	return !*s1 && !*s2;
+}
+
+/* Pass the path to the zipfile and the name of the file within the zipfile.
+   buf will be set to point to the uncompressed image of that zipped file.
+   length will be set to the length of the uncompressed data. */
+int /* error */ load_zipped_file (const char* zipfile, const char* filename, unsigned char** buf, unsigned int* length) {
+	ZIP* zip;
+	struct zipent* ent;
+
+	zip = cache_openzip(zipfile);
+	if (!zip)
+		return -1;
+
+	while (readzip(zip)) {
+		/* NS981003: support for "load by CRC" */
+		char crc[9];
+
+		ent = &(zip->ent);
+
+		sprintf(crc,"%08x",ent->crc32);
+		if (equal_filename(ent->name, filename) ||
+				(ent->crc32 && !strcmp(crc, filename)))
+		{
+			*length = ent->uncompressed_size;
+			*buf = (unsigned char*)malloc( *length );
+			if (!*buf) {
+				if (!gUnzipQuiet)
+					printf("load_zipped_file(): Unable to allocate %d bytes of RAM\n",*length);
+				cache_closezip(zip);
+				return -1;
+			}
+
+			if (readuncompresszip(zip, ent, (char*)*buf)!=0) {
+				free(*buf);
+				cache_closezip(zip);
+				return -1;
+			}
+
+			cache_suspendzip(zip);
+			return 0;
+		}
+	}
+
+	cache_suspendzip(zip);
+	return -1;
+}
+
+/*	Pass the path to the zipfile and the name of the file within the zipfile.
+	sum will be set to the CRC-32 of that zipped file. */
+/*  The caller can preset sum to the expected checksum to enable "load by CRC" */
+int /* error */ checksum_zipped_file (const char *zipfile, const char *filename, unsigned int *length, unsigned int *sum) {
+	ZIP* zip;
+	struct zipent* ent;
+
+	zip = cache_openzip(zipfile);
+	if (!zip)
+		return -1;
+
+	while (readzip(zip)) {
+		ent = &(zip->ent);
+
+		if (equal_filename(ent->name, filename))
+		{
+			*length = ent->uncompressed_size;
+			*sum = ent->crc32;
+			cache_suspendzip(zip);
+			return 0;
+		}
+	}
+
+	cache_suspendzip(zip);
+
+	/* NS981003: support for "load by CRC" */
+	zip = cache_openzip(zipfile);
+	if (!zip)
+		return -1;
+
+	while (readzip(zip)) {
+		ent = &(zip->ent);
+
+		if (*sum && ent->crc32 == *sum)
+		{
+			*length = ent->uncompressed_size;
+			*sum = ent->crc32;
+			cache_suspendzip(zip);
+			return 0;
+		}
+	}
+
+	cache_suspendzip(zip);
+	return -1;
+}
+
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/rominfosrc/src/mame/unzip.h freevo/rominfosrc/src/mame/unzip.h
--- freevo.orig/rominfosrc/src/mame/unzip.h	Wed Dec 31 19:00:00 1969
+++ freevo/rominfosrc/src/mame/unzip.h	Thu Sep  5 08:58:41 2002
@@ -0,0 +1,131 @@
+#ifndef __UNZIP_H
+#define __UNZIP_H
+
+#include "osd_cpu.h"
+#include <stdio.h>
+
+/***************************************************************************
+ * Support for retrieving files from zipfiles
+ ***************************************************************************/
+
+struct zipent {
+	UINT32	cent_file_header_sig;
+	UINT8	version_made_by;
+	UINT8	host_os;
+	UINT8	version_needed_to_extract;
+	UINT8	os_needed_to_extract;
+	UINT16	general_purpose_bit_flag;
+	UINT16	compression_method;
+	UINT16	last_mod_file_time;
+	UINT16	last_mod_file_date;
+	UINT32	crc32;
+	UINT32	compressed_size;
+	UINT32	uncompressed_size;
+	UINT16	filename_length;
+	UINT16	extra_field_length;
+	UINT16	file_comment_length;
+	UINT16	disk_number_start;
+	UINT16	internal_file_attrib;
+	UINT32	external_file_attrib;
+	UINT32	offset_lcl_hdr_frm_frst_disk;
+	char*   name; /* 0 terminated */
+};
+
+typedef struct _ZIP {
+	char* zip; /* zip name */
+	FILE* fp; /* zip handler */
+	long length; /* length of zip file */
+
+	char* ecd; /* end_of_cent_dir data */
+	unsigned ecd_length; /* end_of_cent_dir length */
+
+	char* cd; /* cent_dir data */
+
+	unsigned cd_pos; /* position in cent_dir */
+
+	struct zipent ent; /* buffer for readzip */
+
+	/* end_of_cent_dir */
+	UINT32	end_of_cent_dir_sig;
+	UINT16	number_of_this_disk;
+	UINT16	number_of_disk_start_cent_dir;
+	UINT16	total_entries_cent_dir_this_disk;
+	UINT16	total_entries_cent_dir;
+	UINT32	size_of_cent_dir;
+	UINT32	offset_to_start_of_cent_dir;
+	UINT16	zipfile_comment_length;
+	char*	zipfile_comment; /* pointer in ecd */
+} ZIP;
+
+/* Opens a zip stream for reading
+   return:
+     !=0 success, zip stream
+     ==0 error
+*/
+ZIP* openzip(const char* path);
+
+/* Closes a zip stream */
+void closezip(ZIP* zip);
+
+/* Reads the current entry from a zip stream
+   in:
+     zip opened zip
+   return:
+     !=0 success
+     ==0 error
+*/
+struct zipent* readzip(ZIP* zip);
+
+/* Suspend access to a zip file (release file handler)
+   in:
+      zip opened zip
+   note:
+     A suspended zip is automatically reopened at first call of
+     readuncompressd() or readcompressed() functions
+*/
+void suspendzip(ZIP* zip);
+
+/* Resets a zip stream to the first entry
+   in:
+     zip opened zip
+   note:
+     ZIP file must be opened and not suspended
+*/
+void rewindzip(ZIP* zip);
+
+/* Read compressed data from a zip entry
+   in:
+     zip opened zip
+     ent entry to read
+   out:
+     data buffer for data, ent.compressed_size UINT8s allocated by the caller
+   return:
+     ==0 success
+     <0 error
+*/
+int readcompresszip(ZIP* zip, struct zipent* ent, char* data);
+
+/* Read decompressed data from a zip entry
+   in:
+     zip zip stream open
+     ent entry to read
+   out:
+     data buffer for data, ent.uncompressed_size UINT8s allocated by the caller
+   return:
+     ==0 success
+     <0 error
+*/
+int readuncompresszip(ZIP* zip, struct zipent* ent, char* data);
+
+/* public functions */
+int /* error */ load_zipped_file (const char *zipfile, const char *filename,
+	unsigned char **buf, unsigned int *length);
+int /* error */ checksum_zipped_file (const char *zipfile, const char *filename, unsigned int *length, unsigned int *sum);
+
+void unzip_cache_clear(void);
+
+/* public globals */
+extern int	gUnzipQuiet;	/* flag controls error messages */
+
+#endif
+
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/rominfosrc/src/rominfo.c freevo/rominfosrc/src/rominfo.c
--- freevo.orig/rominfosrc/src/rominfo.c	Wed Dec 31 19:00:00 1969
+++ freevo/rominfosrc/src/rominfo.c	Fri Sep  6 16:45:20 2002
@@ -0,0 +1,354 @@
+/*
+--------------------------------------------------------------------------
+ * ROMInfo - Written by Logiqx (http://www.logiqx.com)
+ *
+ * A simple little utility for identifying emulators that use a specified ROM
+ *
+ *
+ * Modded 2002 for Freevo
+-------------------------------------------------------------------------- 
+*/
+
+#define ROMINFO_VERSION "v1.03freevo"
+#define ROMINFO_DATE "22 August 2002"
+
+/* --- The standard includes --- */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/stat.h>
+
+#include "mame/unzip.h"
+#include "rominfo.h"
+
+int main(int argc, char **argv)
+{
+	struct crc *crcs=0;
+	char dir[BUFFER_SIZE];
+	int errflg = 0;
+
+	if (argc<2)
+	{
+		printf("Usage: %s rom.zip\n\n", basename(argv[0]));
+		errflg++;
+	}
+
+	if (strchr(argv[0], '/'))
+	{
+		strcpy(dir, argv[0]);
+		*strrchr(dir, '/')='\0';
+		chdir(dir);
+	}
+
+	if (!errflg)
+	{
+		if (crcs=load_crcs(argc, argv))
+		{
+			if (crcs[0].crc)
+				errflg=scan_dir("rominfodats", crcs);
+			else
+				printf("ERROR: Not a valid rom\n");
+			free_crcs(crcs);
+		}
+	}
+	return(errflg);
+}
+
+/*
+--------------------------------------------------------------------------
+ * Read CRCs from ZIP file
+ *
+-------------------------------------------------------------------------- 
+*/
+
+struct crc *load_crcs(int argc, char **argv)
+{
+	ZIP *zip;
+	struct zipent *zipent;
+	struct stat buf;
+
+	struct crc *crcs=0;
+	int num_crcs=0;
+	int errflg=0;
+	int i;
+
+	CALLOC(crcs, MAX_CRCS+1, crc)
+
+	for (i=1; !errflg && i<argc; i++)
+	{
+		if (stat(argv[i], &buf) == 0)
+		{
+			if (strstr(argv[i], ".zip"))
+			{
+				/* --- Treat as a ZIP --- */
+				if (zip=openzip(argv[i]))
+				{
+					while ((!errflg) && (zipent=readzip(zip)))
+					{
+						if (num_crcs<MAX_CRCS)
+						{
+							crcs[num_crcs].fn=argv[i];
+							crcs[num_crcs++].crc=zipent->crc32;
+						}
+						else
+						{
+							printf("Too many files in ZIP - max=%d\n", MAX_CRCS);
+							errflg++;
+						}
+					}
+					closezip(zip);
+				}
+				else {
+					errflg++;
+				}
+			}
+			else {
+				errflg++;
+			}
+		}
+		else {
+			errflg++;
+		}
+	}
+	return(crcs);
+}
+
+int free_crcs(struct crc *crcs)
+{
+	CFREE(crcs)
+}
+
+/*
+--------------------------------------------------------------------------
+ * CRC32 calculation of individual file - uses zlib
+ *
+-------------------------------------------------------------------------- 
+*/
+
+unsigned long calc_file_crc32(char *fn, unsigned long fs)
+{
+	FILE *in;
+	unsigned char buf[BLOCK_SIZE];
+	unsigned long crc;
+	unsigned long i=fs;
+	int errflg=0;
+
+	FOPEN(in, fn, "rb")
+	crc = crc32(0, NULL, 0);
+
+	while (!errflg && i)
+	{
+		if (i>=BLOCK_SIZE)
+		{
+			fread(buf, BLOCK_SIZE, 1, in);
+			crc = crc32(crc, buf, BLOCK_SIZE);
+			i-=BLOCK_SIZE;
+		}
+		else
+		{
+			fread(buf, i, 1, in);
+			crc = crc32(crc, buf, i);
+			i=0;
+		}
+	}
+
+	FCLOSE(in)
+	return(crc);
+}
+
+/*
+--------------------------------------------------------------------------
+ * Inidividual Directory scan
+ *
+-------------------------------------------------------------------------- 
+*/
+
+int scan_dir(char *dir, struct crc *crcs)
+{
+	DIR *dirp;                                    
+	struct dirent *direntp;                       
+	struct stat buf;
+
+	char fn[BUFFER_SIZE+1];
+	if (!(dirp=opendir(dir)))
+	{
+		printf("Error: unable to read %s\n", dir);
+	}
+
+	while (dirp && ((direntp = readdir(dirp)) != NULL))
+	{
+		sprintf(fn, "%s/%s", dir, direntp->d_name);
+		if (stat(fn, &buf) == 0)
+		{
+			if (!(buf.st_mode & S_IFDIR))
+			{
+				if (strstr(fn, ".dat"))
+				{
+					scan_dat(fn, crcs);
+				}
+			}
+			else
+			{
+				if (fn[strlen(fn)-1]!='.')	/* Don't try . or .. entries */
+					scan_dir(fn, crcs);
+			}
+		}
+		else
+		{
+			printf("Error getting attributes of %s\n", direntp->d_name);
+		}
+	}
+
+	if (dirp)
+	{
+		closedir(dirp);                               
+	}
+
+	return(0);                                   
+}
+
+/*
+--------------------------------------------------------------------------
+ * Dat scan - Tokenised parser code ripped from CAESAR
+ *
+-------------------------------------------------------------------------- 
+*/
+
+int scan_dat(char *fn, struct crc *crcs)
+{
+	FILE *in;
+
+	char st[BUFFER_SIZE], token[BUFFER_SIZE];
+	char *st_ptr;
+
+	char emu[NAME_LENGTH+1];
+	char game[NAME_LENGTH+1];
+	char rom[NAME_LENGTH+1];
+	char description[NAME_LENGTH+1];
+	char manufacturer[NAME_LENGTH+1];
+	char year[NAME_LENGTH+1];
+
+	char guessgame[NAME_LENGTH+1];
+	char guessrom[NAME_LENGTH+1];
+	char guessdescription[NAME_LENGTH+1];
+	char guessmanufacturer[NAME_LENGTH+1];
+	char guessyear[NAME_LENGTH+1];
+	
+	unsigned long rom_crc;
+	int partialmatch=0;
+	int fullmatch=0;
+	int printed_fn=0;
+	int rom_fn=0;
+	int printed_game=0;
+	int i, errflg=0;
+
+	strcpy(emu, strrchr(fn, '/')+1);
+	*strrchr(emu, '.')='\0';
+
+	FOPEN(in, fn, "r")
+
+	while (!errflg && fgets(st, BUFFER_SIZE, in))
+	{
+		REMOVE_CR_LF(st)
+
+		st_ptr=st;
+		GET_TOKEN(token, st_ptr)
+
+		if (!strcmp(token, "name"))
+		{
+			GET_TOKEN(game, st_ptr)
+			if (printed_game)
+			{
+				if (printed_fn == rom_fn-1) {
+					fullmatch = 1;
+					break; // from the while loop we found a match so why search more?
+				} else if (printed_fn) {
+					if (printed_fn > partialmatch) {
+						strcpy(guessgame,game);
+						strcpy(guessdescription,description);
+						strcpy(guessmanufacturer,manufacturer);
+						strcpy(guessyear,year);
+						partialmatch = printed_fn;
+					}
+				}
+				printed_fn = 0;
+			}
+			printed_game=0;
+		}
+
+		if (!strcmp(token, "description"))
+			GET_TOKEN(description, st_ptr)
+
+		if (!strcmp(token, "year"))
+			GET_TOKEN(year, st_ptr)
+
+		if (!strcmp(token, "manufacturer"))
+			GET_TOKEN(manufacturer, st_ptr)
+
+		if (!strcmp(token, "rom"))
+		{
+			st_ptr=st;
+
+			GET_TOKEN(token, st_ptr) /* skip rom token */
+			GET_TOKEN(token, st_ptr) /* skip bracket */
+			GET_TOKEN(token, st_ptr)
+
+			while (*token)
+			{
+				if (!strcmp(token, "name"))
+					GET_TOKEN(rom, st_ptr)
+
+				if (!strcmp(token, "merge")) {
+					GET_TOKEN(token, st_ptr)
+					token[0]='\0';
+				}
+
+				if (!strcmp(token, "size")) {
+					GET_TOKEN(token, st_ptr)
+					token[0]='\0';
+				}
+
+				if (!strcmp(token, "crc") || !strcmp(token, "crc32"))
+				{
+					GET_TOKEN(token, st_ptr)
+					sscanf(token, "%08lx", &rom_crc);
+					rom_fn=0;
+					for (i=0; i<MAX_CRCS && crcs[i].crc; i++)
+					{
+						rom_fn++;
+						if (rom_crc==crcs[i].crc)
+						{
+							if (!printed_game) {
+								printed_game++;
+							}
+
+							if (crcs[i].fn) {
+								printed_fn++;
+							}
+						}
+					}
+				}
+
+				GET_TOKEN(token, st_ptr)
+			}
+		}
+	}
+	FCLOSE(in)
+	if (fullmatch) {
+		printf("KNOWN: There was a full match\n\n");
+		printf("GAME:         %s\n", game);
+		printf("DESCRIPTION:  %s\n", description);
+		printf("MANUFACTURER: %s\n", manufacturer);
+		printf("YEAR:         %s\n", year);
+	} else if (partialmatch) {
+		printf("PARTIAL: There was a partial match\n\n");
+		printf("GAME:         %s\n", guessgame);
+		printf("DESCRIPTION:  %s\n", guessdescription);
+		printf("MANUFACTURER: %s\n", guessmanufacturer);
+		printf("YEAR:         %s\n", guessyear);
+	}
+}
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/rominfosrc/src/rominfo.h freevo/rominfosrc/src/rominfo.h
--- freevo.orig/rominfosrc/src/rominfo.h	Wed Dec 31 19:00:00 1969
+++ freevo/rominfosrc/src/rominfo.h	Fri Sep  6 05:42:16 2002
@@ -0,0 +1,101 @@
+/*
+--------------------------------------------------------------------------
+ * ROMInfo v1.02 (6 January 2001)
+ * Written by Logiqx (http://www.logiqx.com)
+ *
+ * A simple little utility for identifying emulators that use a
+specified ROM
+ *
+-------------------------------------------------------------------------- 
+*/
+
+/* --- Function prototypes --- */
+
+struct crc *load_crcs(int, char **);
+unsigned long calc_file_crc32(char *, unsigned long);
+
+int scan_dir(char *, struct crc *);
+int scan_dat(char *, struct crc *);
+
+/* --- Size declarations --- */
+
+#define BUFFER_SIZE 1024
+#define NAME_LENGTH 80
+
+#define MAX_CRCS 500
+
+#define BLOCK_SIZE 65536
+
+/* --- Structures --- */
+
+
+struct crc
+{
+	char *fn;
+	unsigned long crc;
+};
+
+/* --- Macros --- */
+
+#define CALLOC(PTR, NUMBER, TYPE) \
+if (!(PTR=calloc(NUMBER, sizeof(struct TYPE)))) \
+{ \
+	printf("Not enough memory\n"); \
+	errflg++; \
+}
+
+#define CFREE(PTR) \
+if (PTR) \
+{ \
+	cfree(PTR);\
+}
+
+#define FOPEN(PTR, FN, MODE) \
+if (!(PTR=fopen(FN, MODE))) \
+{ \
+	printf("Error opening %s for mode '%s'\n", FN, MODE); \
+	errflg++; \
+}
+
+#define FCLOSE(PTR) \
+if (PTR) \
+{ \
+	fclose(PTR); \
+	PTR=0; \
+}
+
+#define REMOVE_CR_LF(ST) \
+while (ST[strlen(ST)-1]==10 || ST[strlen(ST)-1]==13) \
+	ST[strlen(ST)-1]='\0';
+
+#define GET_TOKEN(TOKEN, ST_PTR) \
+{ \
+	int token_idx=0; \
+\
+	while (*ST_PTR==' ' || *ST_PTR=='	') \
+		ST_PTR++; \
+\
+	if (*ST_PTR=='"') \
+	{ \
+		ST_PTR++; \
+		while (*ST_PTR!='"' && *ST_PTR!='\0') \
+		{ \
+			TOKEN[token_idx++]=*ST_PTR; \
+			ST_PTR++; \
+		} \
+		TOKEN[token_idx]='\0';  \
+		if (*ST_PTR!='\0') \
+			ST_PTR++; \
+	} \
+	else \
+	{ \
+		while (*ST_PTR!=' ' && *ST_PTR!='	' && *ST_PTR!='\0') \
+		{ \
+			TOKEN[token_idx++]=*ST_PTR; \
+			ST_PTR++; \
+		} \
+		TOKEN[token_idx]='\0';  \
+	} \
+}
+
+
Binary files freevo.orig/setup_build.pyc and freevo/setup_build.pyc differ
Binary files freevo.orig/skins/main1/skin_main1.pyc and freevo/skins/main1/skin_main1.pyc differ
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/skins/xml/type1/768x576.xml freevo/skins/xml/type1/768x576.xml
--- freevo.orig/skins/xml/type1/768x576.xml	Fri Sep  6 15:54:06 2002
+++ freevo/skins/xml/type1/768x576.xml	Fri Sep  6 16:05:47 2002
@@ -8,7 +8,8 @@
       <item pos="1" name="Movies"   action="movie.main_menu" arg="" visible="yes" icon="icons/movies.png"  />
       <item pos="2" name="Music"    action="music.main_menu" arg="" visible="yes" icon="icons/mp3.png"  />
       <item pos="3" name="Images"   action="imenu.main_menu" arg="" visible="yes" icon="icons/images.png"  />
-      <item pos="4" name="Shutdown" action="shutdown" arg="" visible="yes" icon="icons/shutdown2.png"  />
+      <item pos="4" name="Video Games" action="videogame.main_menu" arg="" visible="yes" icon="icons/mame.png"  />
+      <item pos="5" name="Shutdown" action="shutdown" arg="" visible="yes" icon="icons/shutdown2.png"  />
     </main>
     
     <!-- Settings for a normal menu -->
Binary files freevo.orig/skins/xml/type1/xml_skin.pyc and freevo/skins/xml/type1/xml_skin.pyc differ
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/testfiles/Mame/dir.txt freevo/testfiles/Mame/dir.txt
--- freevo.orig/testfiles/Mame/dir.txt	Wed Dec 31 19:00:00 1969
+++ freevo/testfiles/Mame/dir.txt	Fri Aug 30 05:30:26 2002
@@ -0,0 +1 @@
+Place ROM directories here
diff -Nur -x '*.png' -x '*.zip' -x '*.zip' -x '*.dat' freevo.orig/videogame.py freevo/videogame.py
--- freevo.orig/videogame.py	Wed Dec 31 19:00:00 1969
+++ freevo/videogame.py	Fri Sep  6 17:49:53 2002
@@ -0,0 +1,248 @@
+# ----------------------------------------------------------------------
+# VideoGame.py - the Freevo VideoGame module
+# ----------------------------------------------------------------------
+# $Id$
+#
+# Authors:     Krister Lagerstrom <krister@kmlager.com>
+#              Aubin Paul <aubin@punknews.org>
+#              Dirk Meyer <dischi@tzi.de>
+# Notes:
+# Todo:        
+#
+# ----------------------------------------------------------------------
+#
+# ----------------------------------------------------------------------
+# 
+# Copyright (C) 2002 Krister Lagerstrom
+#
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 2 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of MER-
+# CHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
+# Public License for more details.
+#
+# You should have received a copy of the GNU General Public License along
+# with this program; if not, write to the Free Software Foundation, Inc.,
+# 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+#
+# ----------------------------------------------------------------------
+#
+
+
+import sys
+import random
+import time, os, string
+
+# Configuration file. Determines where to look for AVI/MP3 files, etc
+import config
+
+# Various utilities
+import util
+
+# The menu widget class
+import menu
+
+# The mame class
+import mame
+
+# RegExp
+import re
+
+# The OSD class, used to communicate with the OSD daemon
+import osd
+
+# The RemoteControl class, sets up a UDP daemon that the remote control client
+# sends commands to
+import rc
+
+# Create the remote control object
+rc = rc.get_singleton()
+
+# Create the OSD object
+osd = osd.get_singleton()
+
+# Set to 1 for debug output
+DEBUG = 1
+
+TRUE = 1
+FALSE = 0
+
+# Create the mame object
+mame = mame.get_singleton()
+
+# remember the position of the selected item in the main menu
+main_menu_selected = -1
+
+#
+# mame dummy
+#
+def play_mame( arg=None, menuw=None ):
+    mode = arg[0]
+    filename = arg[1]
+    playlist = arg[2]
+    mame_options = ""
+    if len(arg) > 3:
+        mame_options = arg[3]
+
+    if config.ROM_DRIVES:
+        for rom in config.ROM_DRIVES:
+            if string.find(filename, rom[0]) == 0:
+                util.mount(rom[0])
+    ## Change we dont use playlists ##            
+    mame.play(mode, filename, playlist, 0, mame_options)
+
+
+#
+# EJECT handling
+#
+def eventhandler(event = None, menuw=None, arg=None):
+
+    global main_menu_selected
+    if event == rc.IDENTIFY_MEDIA:
+        if menuw.menustack[1] == menuw.menustack[-1]:
+            main_menu_selected = menuw.all_items.index(menuw.menustack[1].selected)
+
+        menuw.menustack[1].choices = main_menu_generate()
+
+        menuw.menustack[1].selected = menuw.menustack[1].choices[main_menu_selected]
+
+        if menuw.menustack[1] == menuw.menustack[-1]:
+            menuw.init_page()
+            menuw.refresh()
+
+            
+    if event == rc.EJECT:
+
+        rom = arg[0]
+        if not rom:
+            return
+
+        # find the drive
+        pos = 0
+        for (dir, device, name, tray, lastcode, info) in config.ROM_DRIVES:
+            if rom == dir:
+                tray_open = tray
+                config.ROM_DRIVES[pos] = (dir, device, name, (tray + 1) % 2, lastcode, info)
+                break
+            pos += 1
+
+        if tray_open:
+            if DEBUG: print 'Inserting %s' % rom
+            osd.popup_box( 'mounting %s' % rom )
+            osd.update()
+            
+            # close the tray, identifymedia does the rest
+            os.system('eject -t %s' % rom)
+
+        else:
+            if DEBUG: print 'Ejecting %s' % rom
+            os.system('eject %s' % rom)
+        
+
+
+# ======================================================================
+
+
+#
+# The Movie module main menu
+#
+def main_menu_generate():
+    items = []
+
+    for (title, dir) in config.DIR_MAME:
+        items += [menu.MenuItem(title, cwd, dir, eventhandler, type = 'dir')]
+
+    if config.ROM_DRIVES != None: 
+        for (dir, device, name, tray, lastcode, info) in config.ROM_DRIVES:
+            if info:
+                (type, label, image, play_options ) = info
+                if play_options:
+                    m = menu.MenuItem(label, play_mame, play_options, eventhandler, (dir,))
+                elif type != None:
+                    m = menu.MenuItem(label, cwd, dir, eventhandler, (dir,))
+                m.setImage(('movie', image))
+            else:
+                m = menu.MenuItem('%s (no disc)' % name, None, None, eventhandler, (dir,))
+            items += [m]
+            
+    return items
+
+
+def main_menu(arg=None, menuw=None):
+    mamemenu = menu.Menu('VIDEOGAME MAIN MENU', main_menu_generate(), umount_all = 1)
+    menuw.pushmenu(mamemenu)
+
+
+
+#
+# The change directory handling function
+#
+def cwd(arg=None, menuw=None):
+    dir = arg
+
+    if config.ROM_DRIVES:
+        for rom in config.ROM_DRIVES:
+            if rom[0] == dir:
+                util.mount(rom[0])
+                
+    dirnames = util.getdirnames(dir)
+    mame_files = util.match_files(dir, config.SUFFIX_MAME_FILES)
+
+    items = []
+
+    for dirname in dirnames:
+        title = '[' + os.path.basename(dirname) + ']'
+        m = menu.MenuItem(title, cwd, dirname, type = 'dir', eventhandler = eventhandler)
+
+        items += [m]
+
+    
+    files = []
+
+    # Mame files
+    for file in mame_files:
+        title = os.path.splitext(os.path.basename(file))[0]
+        image = None
+        rominfo = os.popen('./rominfo ' + file , 'r')
+        matched = 0
+	partial = 0
+	for line in rominfo.readlines():
+            if string.find(line, 'KNOWN:') != -1:
+                matched = 1
+            if string.find(line, 'PARTIAL:') != -1:
+                partial = 1
+        rominfo.close()
+	if matched == 1:
+            # find image for this file
+            if os.path.isfile(os.path.splitext(file)[0] + ".png"):
+                image = os.path.splitext(file)[0] + ".png"
+            elif os.path.isfile(os.path.splitext(file)[0] + ".jpg"):
+                image = os.path.splitext(file)[0] + ".jpg"
+
+            # add file to list
+            files += [ ( title, 'mame', file, [], None, image ) ]
+
+
+    # sort files by title
+    files.sort(lambda l, o: cmp(l[0].upper(), o[0].upper()))
+
+    # add everything to the menu
+    # AGAIN WE ARE NOT USING PLAYLISTS
+    for (title, mode, file, playlist, mame_options, image) in files:
+        m = menu.MenuItem(title, play_mame, (mode, file, playlist, mame_options),
+                          eventhandler = eventhandler)
+        m.setImage(('movie', image))
+        items += [m]
+    
+    mamemenu = menu.Menu('VIDEOGAME MENU', items, dir=dir)
+
+    if len(menuw.menustack) > 1:
+        if menuw.menustack[1] == menuw.menustack[-1]:
+            global main_menu_selected
+            main_menu_selected = menuw.all_items.index(menuw.menustack[1].selected)
+        
+    menuw.pushmenu(mamemenu)
